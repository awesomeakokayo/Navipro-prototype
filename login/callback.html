<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>OAuth callback — debug</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>body{font-family:system-ui,Segoe UI,Roboto,Arial;padding:16px} pre{background:#f6f6f6;padding:12px;border-radius:6px;overflow:auto}</style>
</head>
<body>
  <h2>OAuth callback — diagnostic</h2>
  <p id="status">Processing...</p>
  <pre id="log"></pre>

  <script src="config.js"></script>
  <script>
    // callback.html simplified processor
    (async function () {
      const logEl = document.getElementById('log');
      function write(...args){ console.log(...args); if (logEl) logEl.textContent += args.map(a => (typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a))).join(' ') + '\n'; }

      function parseParams(str) {
        try { return Object.fromEntries(new URLSearchParams(str)); }
        catch(e) { return {}; }
      }

      function decodeJwtPayload(tok) {
        try {
          const part = tok.split('.')[1];
          const json = atob(part.replace(/-/g,'+').replace(/_/g,'/'));
          return JSON.parse(json);
        } catch (e) { return null; }
      }

      write('[callback] url', window.location.href);
      const search = parseParams(window.location.search.replace(/^\?/, ''));
      const hash = parseParams(window.location.hash.replace(/^#/, ''));
      write('[callback] search', search, 'hash', hash);

      // token and userId can come in search or hash; check both
      let token = search.access_token || search.token || hash.access_token || hash.token || search.jwt || hash.jwt || null;
      let userId = search.user_id || search.userId || hash.user_id || hash.userId || search.id || hash.id || null;
      let redirectUrl = search.redirectUrl || search.redirect || search.redirect_uri || null;

      write('[callback] initial', { hasToken: !!token, hasUserId: !!userId, redirectUrl });

      // If there's a nested redirect param that contains tokens, try to extract
      if ((!token || !userId) && redirectUrl) {
        try {
          const decoded = decodeURIComponent(redirectUrl);
          const u = new URL(decoded);
          const nestedSearch = parseParams(u.search.replace(/^\?/, ''));
          const nestedHash = parseParams(u.hash.replace(/^#/, ''));
          token = token || nestedSearch.access_token || nestedHash.access_token || nestedSearch.token || nestedHash.token || null;
          userId = userId || nestedSearch.user_id || nestedHash.user_id || nestedSearch.userId || nestedHash.userId || null;
          write('[callback] nested extracted', { hasToken: !!token, hasUserId: !!userId });
        } catch (e) {
          write('[callback] no nested redirect token', e);
        }
      }

      // If no token in URL, try cookie-based /auth/me (backend must allow credentials)
      const backend = typeof backendURL !== 'undefined' && backendURL ? backendURL : 'https://naviproai-1.onrender.com';
      if (!token) {
        try {
          write('[callback] trying cookie-based /auth/me');
          const r = await fetch(`${backend}/auth/me`, { credentials: 'include', headers: { 'Content-Type': 'application/json' } });
          write('[callback] cookie /auth/me status', r.status);
          if (r.ok) {
            const body = await r.json();
            token = token || body.access_token || body.token || null;
            userId = userId || body.user_id || body.userId || body.id || (body.user && (body.user.id || body.user._id)) || null;
            write('[callback] cookie-based result hasToken:', !!token, 'hasUserId:', !!userId);
          }
        } catch (e) {
          write('[callback] cookie /auth/me failed', e);
        }
      }

      // If token present but no userId, attempt bearer /auth/me
      if (token && !userId) {
        try {
          write('[callback] calling /auth/me with Bearer token to get user id');
          const r = await fetch(`${backend}/auth/me`, { headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' } });
          if (r.ok) {
            const body = await r.json();
            userId = userId || body.user_id || body.userId || body.id || (body.user && (body.user.id || body.user._id)) || null;
            write('[callback] bearer /auth/me returned userId:', userId);
          } else {
            write('[callback] bearer /auth/me status', r.status);
          }
        } catch (e) {
          write('[callback] bearer /auth/me failed', e);
        }
      }

      // Save consistent storage keys
      if (token) {
        localStorage.setItem('token', token);
        localStorage.setItem('access_token', token);
        localStorage.setItem('jwt', token);
        write('[callback] saved token');
        const payload = decodeJwtPayload(token);
        write('[callback] token payload', payload || 'n/a');
      }
      if (userId) {
        localStorage.setItem('user_id', userId);
        localStorage.setItem('userId', userId);
        write('[callback] saved userId', userId);
      } else {
        write('[callback] WARNING: no userId obtained');
      }

      // final redirect - prefer provided redirectUrl, else dashboard
      const fallback = '../Dashboard/index.html';
      const target = (search.redirectUrl || search.redirect || search.redirect_uri) ? (search.redirectUrl || search.redirect || search.redirect_uri) : (redirectUrl || fallback);
      write('[callback] redirecting to', target);
      setTimeout(() => window.location.replace(target), 600);
    })();
  </script>

</body>
</html>